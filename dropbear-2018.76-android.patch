diff -ruN dropbear-2018.76/configure MOD-dropbear-2018.76/configure
--- dropbear-2018.76/configure	2018-02-27 07:25:13.000000000 -0700
+++ MOD-dropbear-2018.76/configure	2018-04-12 15:21:49.236912000 -0600
@@ -4690,11 +4690,11 @@
 fi
 
 
-if test "t$found_crypt_func" = there; then
+#if test "t$found_crypt_func" = there; then
 
 $as_echo "#define HAVE_CRYPT 1" >>confdefs.h
 
-fi
+#fi
 
 # Check if zlib is needed

diff -ruN dropbear-2018.76/default_options.h MOD-dropbear-2018.76/default_options.h
--- dropbear-2018.76/default_options.h	2018-02-27 07:25:10.000000000 -0700
+++ MOD-dropbear-2018.76/default_options.h	2018-04-13 10:55:29.882055000 -0600
@@ -13,14 +13,14 @@
 
 IMPORTANT: Some options will require "make clean" after changes */
 
-#define DROPBEAR_DEFPORT "22"
+#define DROPBEAR_DEFPORT "10022"
 
 /* Listen on all interfaces */
 #define DROPBEAR_DEFADDRESS ""
 
 /* Default hostkey paths - these can be specified on the command line */
-#define DSS_PRIV_FILENAME "/etc/dropbear/dropbear_dss_host_key"
-#define RSA_PRIV_FILENAME "/etc/dropbear/dropbear_rsa_host_key"
-#define ECDSA_PRIV_FILENAME "/etc/dropbear/dropbear_ecdsa_host_key"
+#define DSS_PRIV_FILENAME "./dropbear_dss_host_key"
+#define RSA_PRIV_FILENAME "./dropbear_rsa_host_key"
+#define ECDSA_PRIV_FILENAME "./dropbear_ecdsa_host_key"
 
 /* Set NON_INETD_MODE if you require daemon functionality (ie Dropbear listens
diff -ruN dropbear-2018.76/runopts.h MOD-dropbear-2018.76/runopts.h
--- dropbear-2018.76/runopts.h	2018-02-27 06:25:12.000000000 -0800
+++ MOD-dropbear-2018.76/runopts.h	2018-12-11 01:10:20.932230000 -0800
@@ -25,6 +25,7 @@
 #ifndef DROPBEAR_RUNOPTS_H_
 #define DROPBEAR_RUNOPTS_H_
 
+#include <pwd.h>
 #include "includes.h"
 #include "signkey.h"
 #include "buffer.h"
@@ -123,6 +124,13 @@
 	buffer * banner;
 	char * pidfile;
 
+	int android_mode;
+    char *user_name;
+    char *passwd;
+    char *authkey;
+    uid_t uid;
+	gid_t gid;
+
 	char * forced_command;
 
 } svr_runopts;
diff -ruN dropbear-2018.76/svr-auth.c MOD-dropbear-2018.76/svr-auth.c
--- dropbear-2018.76/svr-auth.c	2018-02-27 07:25:12.000000000 -0700
+++ MOD-dropbear-2018.76/svr-auth.c	2018-04-13 11:19:33.989962000 -0600
@@ -37,19 +37,26 @@
 #include "runopts.h"
 #include "dbrandom.h"
 
+static void authclear(void);
 static int checkusername(const char *username, unsigned int userlen);
 
 /* initialise the first time for a session, resetting all parameters */
 void svr_authinitialise() {
-	memset(&ses.authstate, 0, sizeof(ses.authstate));
-#if DROPBEAR_SVR_PUBKEY_AUTH
-	ses.authstate.authtypes |= AUTH_TYPE_PUBKEY;
-#endif
-#if DROPBEAR_SVR_PASSWORD_AUTH || DROPBEAR_SVR_PAM_AUTH
-	if (!svr_opts.noauthpass) {
-		ses.authstate.authtypes |= AUTH_TYPE_PASSWORD;
-	}
-#endif
+// 	memset(&ses.authstate, 0, sizeof(ses.authstate));
+// #if DROPBEAR_SVR_PUBKEY_AUTH
+// 	ses.authstate.authtypes |= AUTH_TYPE_PUBKEY;
+// #endif
+// #if DROPBEAR_SVR_PASSWORD_AUTH || DROPBEAR_SVR_PAM_AUTH
+// 	if (!svr_opts.noauthpass) {
+// 		ses.authstate.authtypes |= AUTH_TYPE_PASSWORD;
+// 	}
+// #endif
+	ses.authstate.failcount = 0;
+	ses.authstate.pw_name = NULL;
+	ses.authstate.pw_dir = NULL;
+	ses.authstate.pw_shell = NULL;
+	ses.authstate.pw_passwd = NULL;
+	authclear();
 }
 
 /* Send a banner message if specified to the client. The client might
@@ -146,13 +153,23 @@
 	if (!svr_opts.noauthpass &&
 			!(svr_opts.norootpass && ses.authstate.pw_uid == 0) ) {
 		/* user wants to try password auth */
+		// if (methodlen == AUTH_METHOD_PASSWORD_LEN &&
+		// 		strncmp(methodname, AUTH_METHOD_PASSWORD,
+		// 			AUTH_METHOD_PASSWORD_LEN) == 0) {
+		// 	if (valid_user) {
+		// 		svr_auth_password();
+		// 		goto out;
+		// 	}
+		// }
 		if (methodlen == AUTH_METHOD_PASSWORD_LEN &&
 				strncmp(methodname, AUTH_METHOD_PASSWORD,
 					AUTH_METHOD_PASSWORD_LEN) == 0) {
-			if (valid_user) {
-				svr_auth_password();
+				if (svr_opts.android_mode) {
+					svr_auth_android();
+				} else if (valid_user) {
+					svr_auth_password();
+				}
 				goto out;
-			}
 		}
 	}
 #endif
@@ -233,6 +250,35 @@
 }
 #endif
 
+/* Reset the auth state, but don't reset the failcount. This is for if the
+ * user decides to try with a different username etc, and is also invoked
+ * on initialisation */
+static void authclear() {
+	
+	memset(&ses.authstate, 0, sizeof(ses.authstate));
+#if DROPBEAR_SVR_PUBKEY_AUTH
+	ses.authstate.authtypes |= AUTH_TYPE_PUBKEY;
+#endif
+#if DROPBEAR_SVR_PASSWORD_AUTH || DROPBEAR_SVR_PAM_AUTH
+	if (!svr_opts.noauthpass) {
+		ses.authstate.authtypes |= AUTH_TYPE_PASSWORD;
+	}
+#endif
+	if (ses.authstate.pw_name) {
+		m_free(ses.authstate.pw_name);
+	}
+	if (ses.authstate.pw_shell) {
+		m_free(ses.authstate.pw_shell);
+	}
+	if (ses.authstate.pw_dir) {
+		m_free(ses.authstate.pw_dir);
+	}
+	if (ses.authstate.pw_passwd) {
+		m_free(ses.authstate.pw_passwd);
+	}
+	
+}
+
 /* Check that the username exists and isn't disallowed (root), and has a valid shell.
  * returns DROPBEAR_SUCCESS on valid username, DROPBEAR_FAILURE on failure */
 static int checkusername(const char *username, unsigned int userlen) {
@@ -251,10 +297,44 @@
 			svr_ses.addrstring);
 	}
 
-	if (ses.authstate.username == NULL) {
-		/* first request */
-		fill_passwd(username);
-		ses.authstate.username = m_strdup(username);
+	// if (ses.authstate.username == NULL) {
+	// 	/* first request */
+	// 	fill_passwd(username);
+	// 	ses.authstate.username = m_strdup(username);
+	// }
+	if (ses.authstate.username == NULL ||
+		strcmp(username, ses.authstate.username) != 0) {
+			/* the username needs resetting */
+			if (ses.authstate.username != NULL) {
+				dropbear_log(LOG_WARNING, "Client trying multiple usernames from %s",
+							svr_ses.addrstring);
+				m_free(ses.authstate.username);
+			}
+			authclear();
+			if (svr_opts.android_mode) {
+				ses.authstate.pw_uid = svr_opts.uid;
+				ses.authstate.pw_gid = svr_opts.gid;
+				if (svr_opts.user_name != NULL) {
+					ses.authstate.pw_name = m_strdup(svr_opts.user_name);
+				} else {
+					dropbear_log(LOG_WARNING, "Username null");
+					ses.authstate.pw_name = m_strdup("nobody");
+				}
+
+				if (svr_opts.passwd != NULL) {
+					ses.authstate.pw_passwd = m_strdup(svr_opts.passwd);
+				} else {
+					dropbear_log(LOG_WARNING, "Password null");
+					ses.authstate.pw_passwd = m_strdup("");
+				}
+
+				ses.authstate.pw_dir = m_strdup("/data/local");
+				ses.authstate.pw_shell = m_strdup("/system/bin/sh");
+			} else {
+				dropbear_log(LOG_WARNING, "NOT android mode!!");
+				fill_passwd(username);
+				ses.authstate.username = m_strdup(username);
+			}
 	} else {
 		/* check username hasn't changed */
 		if (strcmp(username, ses.authstate.username) != 0) {
@@ -323,6 +403,9 @@
 		usershell = "/bin/sh";
 	}
 
+	if (svr_opts.android_mode)
+		goto goodshell;
+
 	/* check the shell is valid. If /etc/shells doesn't exist, getusershell()
 	 * should return some standard shells like "/bin/sh" and "/bin/csh" (this
 	 * is platform-specific) */
diff -ruN dropbear-2018.76/svr-authpasswd.c MOD-dropbear-2018.76/svr-authpasswd.c
--- dropbear-2018.76/svr-authpasswd.c	2018-02-27 07:25:12.000000000 -0700
+++ MOD-dropbear-2018.76/svr-authpasswd.c	2018-04-13 12:21:52.574971000 -0600
@@ -48,22 +48,12 @@
 
 /* Process a password auth request, sending success or failure messages as
  * appropriate */
-void svr_auth_password() {
-	
-	char * passwdcrypt = NULL; /* the crypt from /etc/passwd or /etc/shadow */
-	char * testcrypt = NULL; /* crypt generated from the user's password sent */
-	char * password;
+void svr_auth_android() {
+	char *password;
 	unsigned int passwordlen;
 
 	unsigned int changepw;
 
-	passwdcrypt = ses.authstate.pw_passwd;
-
-#ifdef DEBUG_HACKCRYPT
-	/* debugging crypt for non-root testing with shadows */
-	passwdcrypt = DEBUG_HACKCRYPT;
-#endif
-
 	/* check if client wants to change password */
 	changepw = buf_getbool(ses.payload);
 	if (changepw) {
@@ -74,28 +64,15 @@
 
 	password = buf_getstring(ses.payload, &passwordlen);
 
-	/* the first bytes of passwdcrypt are the salt */
-	testcrypt = crypt(password, passwdcrypt);
-	m_burn(password, passwordlen);
-	m_free(password);
-
-	if (testcrypt == NULL) {
-		/* crypt() with an invalid salt like "!!" */
-		dropbear_log(LOG_WARNING, "User account '%s' is locked",
-				ses.authstate.pw_name);
-		send_msg_userauth_failure(0, 1);
-		return;
-	}
-
 	/* check for empty password */
-	if (passwdcrypt[0] == '\0') {
-		dropbear_log(LOG_WARNING, "User '%s' has blank password, rejected",
+	if (password[0] == '\0') {
+		dropbear_log(LOG_WARNING, "user '%s' has blank password, rejected",
 				ses.authstate.pw_name);
 		send_msg_userauth_failure(0, 1);
 		return;
 	}
-
-	if (constant_time_strcmp(testcrypt, passwdcrypt) == 0) {
+	
+	if (constant_time_strcmp(password, svr_opts.passwd) == 0) {
 		/* successful authentication */
 		dropbear_log(LOG_NOTICE, 
 				"Password auth succeeded for '%s' from %s",
@@ -111,4 +88,10 @@
 	}
 }
 
+/* Process a password auth request, sending success or failure messages as
+ * appropriate */
+void svr_auth_password() {
+	send_msg_userauth_failure(0, 1);
+}
+
 #endif
diff -ruN dropbear-2018.76/svr-authpasswd.c.bak MOD-dropbear-2018.76/svr-authpasswd.c.bak
--- dropbear-2018.76/svr-authpasswd.c.bak	1969-12-31 17:00:00.000000000 -0700
+++ MOD-dropbear-2018.76/svr-authpasswd.c.bak	2018-02-27 07:25:12.000000000 -0700
@@ -0,0 +1,114 @@
+/*
+ * Dropbear - a SSH2 server
+ * 
+ * Copyright (c) 2002,2003 Matt Johnston
+ * All rights reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE. */
+
+/* Validates a user password */
+
+#include "includes.h"
+#include "session.h"
+#include "buffer.h"
+#include "dbutil.h"
+#include "auth.h"
+#include "runopts.h"
+
+#if DROPBEAR_SVR_PASSWORD_AUTH
+
+/* not constant time when strings are differing lengths. 
+ string content isn't leaked, and crypt hashes are predictable length. */
+static int constant_time_strcmp(const char* a, const char* b) {
+	size_t la = strlen(a);
+	size_t lb = strlen(b);
+
+	if (la != lb) {
+		return 1;
+	}
+
+	return constant_time_memcmp(a, b, la);
+}
+
+/* Process a password auth request, sending success or failure messages as
+ * appropriate */
+void svr_auth_password() {
+	
+	char * passwdcrypt = NULL; /* the crypt from /etc/passwd or /etc/shadow */
+	char * testcrypt = NULL; /* crypt generated from the user's password sent */
+	char * password;
+	unsigned int passwordlen;
+
+	unsigned int changepw;
+
+	passwdcrypt = ses.authstate.pw_passwd;
+
+#ifdef DEBUG_HACKCRYPT
+	/* debugging crypt for non-root testing with shadows */
+	passwdcrypt = DEBUG_HACKCRYPT;
+#endif
+
+	/* check if client wants to change password */
+	changepw = buf_getbool(ses.payload);
+	if (changepw) {
+		/* not implemented by this server */
+		send_msg_userauth_failure(0, 1);
+		return;
+	}
+
+	password = buf_getstring(ses.payload, &passwordlen);
+
+	/* the first bytes of passwdcrypt are the salt */
+	testcrypt = crypt(password, passwdcrypt);
+	m_burn(password, passwordlen);
+	m_free(password);
+
+	if (testcrypt == NULL) {
+		/* crypt() with an invalid salt like "!!" */
+		dropbear_log(LOG_WARNING, "User account '%s' is locked",
+				ses.authstate.pw_name);
+		send_msg_userauth_failure(0, 1);
+		return;
+	}
+
+	/* check for empty password */
+	if (passwdcrypt[0] == '\0') {
+		dropbear_log(LOG_WARNING, "User '%s' has blank password, rejected",
+				ses.authstate.pw_name);
+		send_msg_userauth_failure(0, 1);
+		return;
+	}
+
+	if (constant_time_strcmp(testcrypt, passwdcrypt) == 0) {
+		/* successful authentication */
+		dropbear_log(LOG_NOTICE, 
+				"Password auth succeeded for '%s' from %s",
+				ses.authstate.pw_name,
+				svr_ses.addrstring);
+		send_msg_userauth_success();
+	} else {
+		dropbear_log(LOG_WARNING,
+				"Bad password attempt for '%s' from %s",
+				ses.authstate.pw_name,
+				svr_ses.addrstring);
+		send_msg_userauth_failure(0, 1);
+	}
+}
+
+#endif
diff -ruN dropbear-2018.76/svr-authpubkey.c MOD-dropbear-2018.76/svr-authpubkey.c
--- dropbear-2018.76/svr-authpubkey.c	2018-02-27 07:25:12.000000000 -0700
+++ MOD-dropbear-2018.76/svr-authpubkey.c	2018-04-13 09:56:18.319287000 -0600
@@ -64,6 +64,7 @@
 #include "ssh.h"
 #include "packet.h"
 #include "algo.h"
+#include "runopts.h"
 
 #if DROPBEAR_SVR_PUBKEY_AUTH
 
@@ -315,19 +316,23 @@
 	}
 
 	/* check file permissions, also whether file exists */
-	if (checkpubkeyperms() == DROPBEAR_FAILURE) {
+	if (!svr_opts.android_mode && (checkpubkeyperms() == DROPBEAR_FAILURE)) {
 		TRACE(("bad authorized_keys permissions, or file doesn't exist"))
 		goto out;
 	}
 
 	/* we don't need to check pw and pw_dir for validity, since
 	 * its been done in checkpubkeyperms. */
-	len = strlen(ses.authstate.pw_dir);
-	/* allocate max required pathname storage,
-	 * = path + "/.ssh/authorized_keys" + '\0' = pathlen + 22 */
-	filename = m_malloc(len + 22);
-	snprintf(filename, len + 22, "%s/.ssh/authorized_keys", 
-				ses.authstate.pw_dir);
+	if (svr_opts.android_mode) {
+		if (svr_opts.authkey == NULL)
+			goto out;
+		filename = m_strdup(svr_opts.authkey);
+	} else {
+		/* allocate max required pathname storage,
+	 	* = path + "/.ssh/authorized_keys" + '\0' = pathlen + 22 */
+		filename = m_malloc(31);
+		snprintf(filename, 31, "/data/dropbear/authorized_keys");
+	}
 
 	/* open the file as the authenticating user. */
 	origuid = getuid();
diff -ruN dropbear-2018.76/svr-chansession.c MOD-dropbear-2018.76/svr-chansession.c
--- dropbear-2018.76/svr-chansession.c	2018-02-27 07:25:12.000000000 -0700
+++ MOD-dropbear-2018.76/svr-chansession.c	2018-04-13 09:52:05.154533000 -0600
@@ -593,11 +593,23 @@
 		dropbear_exit("Out of memory"); /* TODO disconnect */
 	}
 
-	pw = getpwnam(ses.authstate.pw_name);
+	if (svr_opts.android_mode) {
+		pw = malloc(sizeof(struct passwd));
+		pw->pw_uid = svr_opts.uid;
+		pw->pw_gid = svr_opts.gid;
+	} else {
+		pw = getpwnam(ses.authstate.pw_name);
+	}
+
 	if (!pw)
 		dropbear_exit("getpwnam failed after succeeding previously");
+	
 	pty_setowner(pw, chansess->tty);
 
+	if (svr_opts.android_mode) {
+		free(pw);
+	}
+
 	/* Set up the rows/col counts */
 	sessionwinchange(chansess);
 
@@ -961,7 +973,20 @@
 	addnewvar("LOGNAME", ses.authstate.pw_name);
 	addnewvar("HOME", ses.authstate.pw_dir);
 	addnewvar("SHELL", get_user_shell());
-	addnewvar("PATH", DEFAULT_PATH);
+
+	if (svr_opts.android_mode) {
+		addnewvar("PATH", "/sbin:/system/sbin:/system/bin:/system/xbin");
+		addnewvar("ANDROID_ASSETS", "/system/app");
+		addnewvar("ANDROID_BOOTLOGO", "1");
+		addnewvar("ANDROID_DATA", "/data");
+		addnewvar("ANDROID_PROPERTY_WORKSPACE", "10,32768");
+		addnewvar("ANDROID_ROOT", "/system");
+		addnewvar("BOOTCLASSPATH", "/system/framework/core.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/android.policy.jar:/system/framework/services.jar");
+		addnewvar("EXTERNAL_STORAGE", "/sdcard");
+	} else {
+		addnewvar("PATH", DEFAULT_PATH);
+	}
+
 	if (chansess->term != NULL) {
 		addnewvar("TERM", chansess->term);
 	}
diff -ruN dropbear-2018.76/svr-runopts.c MOD-dropbear-2018.76/svr-runopts.c
--- dropbear-2018.76/svr-runopts.c	2018-02-27 07:25:12.000000000 -0700
+++ MOD-dropbear-2018.76/svr-runopts.c	2018-04-13 09:48:34.333137000 -0600
@@ -42,6 +42,12 @@
 static void printhelp(const char * progname) {
 
 	fprintf(stderr, "Dropbear server v%s https://matt.ucc.asn.au/dropbear/dropbear.html\n"
+					"-A Android Mode, specify a user explicitly\n"
+					"-N Android Mode, user name\n"
+					"-C Android Mode, password\n"
+					"-T Android Mode, public key file (authorized_keys)\n"               
+					"-U Android Mode, UID\n"
+					"-G Android Mode, GID\n"
 					"Usage: %s [options]\n"
 					"-b bannerfile	Display the contents of bannerfile"
 					" before user login\n"
@@ -122,6 +128,7 @@
 
 	unsigned int i, j;
 	char ** next = NULL;
+	int nextisint = 0;
 	int nextisport = 0;
 	char* recv_window_arg = NULL;
 	char* keepalive_arg = NULL;
@@ -150,6 +157,12 @@
 	svr_opts.hostkey = NULL;
 	svr_opts.delay_hostkey = 0;
 	svr_opts.pidfile = DROPBEAR_PIDFILE;
+	svr_opts.android_mode = 0;
+	svr_opts.user_name = NULL;
+	svr_opts.passwd = NULL;
+	svr_opts.authkey = NULL;
+	svr_opts.uid = 0;
+	svr_opts.gid = 0;
 #if DROPBEAR_SVR_LOCALTCPFWD
 	svr_opts.nolocaltcp = 0;
 #endif
@@ -185,6 +198,26 @@
 
 		for (j = 1; (c = argv[i][j]) != '\0' && !next && !nextisport; j++) {
 			switch (c) {
+				case 'A':
+					svr_opts.android_mode = 1;
+					break;
+				case 'N':
+					next = &svr_opts.user_name;
+					break;
+				case 'C':
+					next = &svr_opts.passwd;
+					break;
+				case 'T':
+					next = &svr_opts.authkey;
+					break;
+				case 'U':
+					next = &svr_opts.uid;
+					nextisint = 1;
+					break;
+				case 'G':
+					next = &svr_opts.gid;
+					nextisint = 1;
+					break;
 				case 'b':
 					next = &svr_opts.bannerfile;
 					break;
@@ -239,11 +272,11 @@
 				case 'w':
 					svr_opts.norootlogin = 1;
 					break;
-#ifdef HAVE_GETGROUPLIST
-				case 'G':
-					next = &svr_opts.restrict_group;
-					break;
-#endif
+// #ifdef HAVE_GETGROUPLIST
+// 				case 'G':
+// 					next = &svr_opts.restrict_group;
+// 					break;
+// #endif
 				case 'W':
 					next = &recv_window_arg;
 					break;
@@ -253,9 +286,9 @@
 				case 'I':
 					next = &idle_timeout_arg;
 					break;
-				case 'T':
-					next = &maxauthtries_arg;
-					break;
+				// case 'T':
+				// 	next = &maxauthtries_arg;
+				// 	break;
 #if DROPBEAR_SVR_PASSWORD_AUTH || DROPBEAR_SVR_PAM_AUTH
 				case 's':
 					svr_opts.noauthpass = 1;
@@ -302,6 +335,13 @@
 			}
 		}
 
+		if (nextisint) {
+			*next = atoi(argv[i]);
+			nextisint = 0;
+			next = 0x00;
+			continue;
+		}
+
 		if (nextisport) {
 			addportandaddress(&argv[i][j]);
 			nextisport = 0;

diff -ruN dropbear-2018.76/sysoptions.h MOD-dropbear-2018.76/sysoptions.h
--- dropbear-2018.76/sysoptions.h	2018-02-27 07:25:12.000000000 -0700
+++ MOD-dropbear-2018.76/sysoptions.h	2018-04-12 15:22:33.624601000 -0600
@@ -233,9 +233,9 @@
 #error "DROPBEAR_SVR_PATM_AUTH requires PAM headers. Perhaps ./configure --enable-pam ?"
 #endif
 
-#if DROPBEAR_SVR_PASSWORD_AUTH && !HAVE_CRYPT
-	#error "DROPBEAR_SVR_PASSWORD_AUTH requires `crypt()'."
-#endif
+//#if DROPBEAR_SVR_PASSWORD_AUTH && !HAVE_CRYPT
+//	#error "DROPBEAR_SVR_PASSWORD_AUTH requires `crypt()'."
+//#endif
 
 #if !(DROPBEAR_SVR_PASSWORD_AUTH || DROPBEAR_SVR_PAM_AUTH || DROPBEAR_SVR_PUBKEY_AUTH)
 	#error "At least one server authentication type must be enabled. DROPBEAR_SVR_PUBKEY_AUTH and DROPBEAR_SVR_PASSWORD_AUTH are recommended."

diff -uprN dropbear-2018.76/netbsd_getpass.c dropbear-2018.76-android/netbsd_getpass.c
--- dropbear-2018.76/netbsd_getpass.c	1970-01-01 01:00:00.000000000 +0100
+++ dropbear-2018.76-android/netbsd_getpass.c	2015-07-01 08:34:12.000000000 +0200
@@ -0,0 +1,114 @@
+/*	$NetBSD: getpass.c,v 1.15 2003/08/07 16:42:50 agc Exp $	*/
+
+/*
+ * Copyright (c) 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if 0
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)getpass.c	8.1 (Berkeley) 6/4/93";
+#else
+__RCSID("$NetBSD: getpass.c,v 1.15 2003/08/07 16:42:50 agc Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#endif
+
+#include <assert.h>
+#include <paths.h>
+#include <pwd.h>
+#include <signal.h>
+#include <stdio.h>
+#include <termios.h>
+#include <unistd.h>
+
+#if 0
+#ifdef __weak_alias
+__weak_alias(getpass,_getpass)
+#endif
+#endif
+
+char *
+getpass(prompt)
+	const char *prompt;
+{
+	struct termios term;
+	int ch;
+	char *p;
+	FILE *fp, *outfp;
+	int echo;
+	static char buf[_PASSWORD_LEN + 1];
+	sigset_t oset, nset;
+
+#if 0
+	_DIAGASSERT(prompt != NULL);
+#endif
+
+	/*
+	 * read and write to /dev/tty if possible; else read from
+	 * stdin and write to stderr.
+	 */
+	if ((outfp = fp = fopen(_PATH_TTY, "w+")) == NULL) {
+		outfp = stderr;
+		fp = stdin;
+	}
+
+	/*
+	 * note - blocking signals isn't necessarily the
+	 * right thing, but we leave it for now.
+	 */
+	sigemptyset(&nset);
+	sigaddset(&nset, SIGINT);
+	sigaddset(&nset, SIGTSTP);
+	(void)sigprocmask(SIG_BLOCK, &nset, &oset);
+
+	(void)tcgetattr(fileno(fp), &term);
+	if ((echo = (term.c_lflag & ECHO)) != 0) {
+		term.c_lflag &= ~ECHO;
+		(void)tcsetattr(fileno(fp), TCSAFLUSH /*|TCSASOFT*/, &term);
+	}
+	if (prompt != NULL)
+		(void)fputs(prompt, outfp);
+	rewind(outfp);			/* implied flush */
+	for (p = buf; (ch = getc(fp)) != EOF && ch != '\n';)
+		if (p < buf + _PASSWORD_LEN)
+			*p++ = ch;
+	*p = '\0';
+	(void)write(fileno(outfp), "\n", 1);
+	if (echo) {
+		term.c_lflag |= ECHO;
+		(void)tcsetattr(fileno(fp), TCSAFLUSH/*|TCSASOFT*/, &term);
+	}
+	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
+	if (fp != stdin)
+		(void)fclose(fp);
+	return(buf);
+}

diff -uprN dropbear-2018.76/netbsd_getpass.h dropbear-2018.76-android/netbsd_getpass.h
--- dropbear-2018.76/netbsd_getpass.h	1970-01-01 01:00:00.000000000 +0100
+++ dropbear-2018.76-android/netbsd_getpass.h	2015-07-01 08:46:00.000000000 +0200
@@ -0,0 +1,4 @@
+#ifndef __GETPASS_H__
+#define __GETPASS_H__
+extern char *getpass (const char *prompt);
+#endif

diff -ruN dropbear-2018.76/cli-auth.c MOD-dropbear-2018.76/cli-auth.c
--- dropbear-2018.76/cli-auth.c	2018-02-27 06:25:10.000000000 -0800
+++ MOD-dropbear-2018.76/cli-auth.c	2018-12-11 02:22:23.543648000 -0800
@@ -31,6 +31,7 @@
 #include "ssh.h"
 #include "packet.h"
 #include "runopts.h"
+#include "netbsd_getpass.h"
 
 void cli_authinitialise() {

diff -ruN dropbear-2018.76/Makefile.in MOD-dropbear-2018.76/Makefile.in
--- dropbear-2018.76/Makefile.in	2018-02-27 06:25:10.000000000 -0800
+++ MOD-dropbear-2018.76/Makefile.in	2018-12-11 01:09:15.025765000 -0800
@@ -46,7 +46,7 @@
 CLIOBJS=cli-main.o cli-auth.o cli-authpasswd.o cli-kex.o \
 		cli-session.o cli-runopts.o cli-chansession.o \
 		cli-authpubkey.o cli-tcpfwd.o cli-channel.o cli-authinteract.o \
-		cli-agentfwd.o 
+		cli-agentfwd.o netbsd_getpass.o
 
 CLISVROBJS=common-session.o packet.o common-algo.o common-kex.o \
 			common-channel.o common-chansession.o termcodes.o loginrec.o \

diff -uprN dropbear-2018.76/sshpty.c dropbear-2018.76_mod/sshpty.c
--- dropbear-2018.76/sshpty.c	2018-02-27 23:25:12.000000000 +0900
+++ dropbear-2018.76_mod/sshpty.c	2018-12-08 21:13:13.805137041 +0900
@@ -22,6 +22,8 @@
 #include "errno.h"
 #include "sshpty.h"
 
+#define HAVE_OPENPTY
+
 /* Pty allocated with _getpty gets broken if we do I_PUSH:es to it. */
 #if defined(HAVE__GETPTY) || defined(HAVE_OPENPTY)
 #undef HAVE_DEV_PTMX
@@ -38,6 +40,50 @@
 #define O_NOCTTY 0
 #endif
 
+int
+openpty (int *amaster, int *aslave, char *name, struct termios *termp,
+		struct winsize *winp)
+{
+	int master, slave;
+	char *name_slave;
+
+	master = open("/dev/ptmx", O_RDWR | O_NONBLOCK);
+	if (master == -1) {
+		TRACE(("Fail to open master"))
+		return -1;
+	}
+
+	if (grantpt(master))
+		goto fail;
+
+	if (unlockpt(master))
+		goto fail;
+
+	name_slave = ptsname(master);
+	TRACE(("openpty: slave name %s", name_slave))
+	slave = open(name_slave, O_RDWR | O_NOCTTY);
+	if (slave == -1)
+		{
+			goto fail;
+		}
+
+	if(termp)
+		tcsetattr(slave, TCSAFLUSH, termp);
+	if (winp)
+		ioctl (slave, TIOCSWINSZ, winp);
+
+	*amaster = master;
+	*aslave = slave;
+	if (name != NULL)
+		strcpy(name, name_slave);
+
+	return 0;
+
+  fail:
+	close (master);
+	return -1;
+}
+
 /*
  * Allocates and opens a pty.  Returns 0 if no pty could be allocated, or
  * nonzero if a pty was successfully allocated.  On success, open file

diff -ruN dropbear-2018.76/config.guess MOD-dropbear-2018.76/config.guess
--- dropbear-2018.76/config.guess	2018-12-13 10:00:26.254962578 -0800
+++ MOD-dropbear-2018.76/config.guess	2018-12-13 09:59:42.143988107 -0800
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright 1992-2013 Free Software Foundation, Inc.
+#   Copyright 1992-2015 Free Software Foundation, Inc.
 
-timestamp='2013-06-10'
+timestamp='2015-03-04'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -24,12 +24,12 @@
 # program.  This Exception is an additional permission under section 7
 # of the GNU General Public License, version 3 ("GPLv3").
 #
-# Originally written by Per Bothner.
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
 # You can get the latest version of this script from:
 # http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
 #
-# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+# Please send patches to <config-patches@gnu.org>.
 
 
 me=`echo "$0" | sed -e 's,.*/,,'`
@@ -50,7 +50,7 @@
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright 1992-2013 Free Software Foundation, Inc.
+Copyright 1992-2015 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -149,7 +149,7 @@
 	LIBC=gnu
 	#endif
 	EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
 	;;
 esac
 
@@ -168,20 +168,27 @@
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
 	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
-	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+	    /sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || \
+	    echo unknown)`
 	case "${UNAME_MACHINE_ARCH}" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
+	    earmv*)
+		arch=`echo ${UNAME_MACHINE_ARCH} | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo ${UNAME_MACHINE_ARCH} | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine=${arch}${endian}-unknown
+		;;
 	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
 	# to ELF recently, or will in the future.
 	case "${UNAME_MACHINE_ARCH}" in
-	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+	    arm*|earm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
 			| grep -q __ELF__
@@ -197,6 +204,13 @@
 		os=netbsd
 		;;
 	esac
+	# Determine ABI tags.
+	case "${UNAME_MACHINE_ARCH}" in
+	    earm*)
+		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+		abi=`echo ${UNAME_MACHINE_ARCH} | sed -e "$expr"`
+		;;
+	esac
 	# The OS release
 	# Debian GNU/NetBSD machines have a different userland, and
 	# thus, need a distinct triplet. However, they do not need
@@ -213,7 +227,7 @@
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
+	echo "${machine}-${os}${release}${abi}"
 	exit ;;
     *:Bitrig:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
@@ -579,8 +593,9 @@
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
+	if [ -x /usr/bin/lslpp ] ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
@@ -826,7 +841,7 @@
     *:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit ;;
-    i*:MSYS*:*)
+    *:MSYS*:*)
 	echo ${UNAME_MACHINE}-pc-msys
 	exit ;;
     i*:windows32*:*)
@@ -932,6 +947,9 @@
     crisv32:Linux:*:*)
 	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
+    e2k:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     frv:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
@@ -969,10 +987,10 @@
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
 	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
 	;;
-    or1k:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+    openrisc*:Linux:*:*)
+	echo or1k-unknown-linux-${LIBC}
 	exit ;;
-    or32:Linux:*:*)
+    or32:Linux:*:* | or1k*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     padre:Linux:*:*)
@@ -1260,16 +1278,26 @@
 	if test "$UNAME_PROCESSOR" = unknown ; then
 	    UNAME_PROCESSOR=powerpc
 	fi
-	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		grep IS_64BIT_ARCH >/dev/null
-	    then
-		case $UNAME_PROCESSOR in
-		    i386) UNAME_PROCESSOR=x86_64 ;;
-		    powerpc) UNAME_PROCESSOR=powerpc64 ;;
-		esac
+	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
+	    if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		    (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		    grep IS_64BIT_ARCH >/dev/null
+		then
+		    case $UNAME_PROCESSOR in
+			i386) UNAME_PROCESSOR=x86_64 ;;
+			powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		    esac
+		fi
 	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # Avoid executing cc on OS X 10.9, as it ships with a stub
+	    # that puts up a graphical alert prompting to install
+	    # developer tools.  Any system running Mac OS X 10.7 or
+	    # later (Darwin 11 and later) is required to have a 64-bit
+	    # processor. This is not true of the ARM version of Darwin
+	    # that Apple uses in portable devices.
+	    UNAME_PROCESSOR=x86_64
 	fi
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
 	exit ;;
@@ -1361,154 +1389,6 @@
 	exit ;;
 esac
 
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
-#ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
-     I don't know....  */
-  printf ("mips-sony-bsd\n"); exit (0);
-#else
-#include <sys/param.h>
-  printf ("m68k-sony-newsos%s\n",
-#ifdef NEWSOS4
-	"4"
-#else
-	""
-#endif
-	); exit (0);
-#endif
-#endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ "m68k"
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  if (version < 4)
-    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
-  else
-    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf ("ns32k-encore-sysv\n"); exit (0);
-#else
-#if defined (CMU)
-  printf ("ns32k-encore-mach\n"); exit (0);
-#else
-  printf ("ns32k-encore-bsd\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf ("i386-pc-bsd\n"); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf ("i386-sequent-dynix\n"); exit (0);
-#endif
-#if defined (ns32000)
-  printf ("ns32k-sequent-dynix\n"); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
-
-#endif
-
-#if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
-#endif
-
-#if defined (alliant) && defined (i860)
-  printf ("i860-alliant-bsd\n"); exit (0);
-#endif
-
-  exit (1);
-}
-EOF
-
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
-	{ echo "$SYSTEM_NAME"; exit; }
-
-# Apollos put the system type in the environment.
-
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
-
-# Convex versions that predate uname can use getsysinfo(1)
-
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-	exit ;;
-    c34*)
-	echo c34-convex-bsd
-	exit ;;
-    c38*)
-	echo c38-convex-bsd
-	exit ;;
-    c4*)
-	echo c4-convex-bsd
-	exit ;;
-    esac
-fi
-
 cat >&2 <<EOF
 $0: unable to guess system type
 
diff -ruN dropbear-2018.76/config.sub MOD-dropbear-2018.76/config.sub
--- dropbear-2018.76/config.sub		2018-12-13 10:28:40.023628677 -0800
+++ MOD-dropbear-2018.76/config.sub	2018-12-13 10:22:23.492362005 -0800
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright 1992-2013 Free Software Foundation, Inc.
+#   Copyright 1992-2015 Free Software Foundation, Inc.
 
-timestamp='2013-10-01'
+timestamp='2015-03-08'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -25,7 +25,7 @@
 # of the GNU General Public License, version 3 ("GPLv3").
 
 
-# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+# Please send patches to <config-patches@gnu.org>.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
@@ -68,7 +68,7 @@
 version="\
 GNU config.sub ($timestamp)
 
-Copyright 1992-2013 Free Software Foundation, Inc.
+Copyright 1992-2015 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -117,7 +117,7 @@
 case $maybe_os in
   nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
   linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
-  knetbsd*-gnu* | netbsd*-gnu* | \
+  knetbsd*-gnu* | netbsd*-gnu* | netbsd*-eabi* | \
   kopensolaris*-gnu* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
@@ -259,8 +259,8 @@
 	| bfin \
 	| c4x | c8051 | clipper \
 	| d10v | d30v | dlx | dsp16xx \
-	| epiphany \
-	| fido | fr30 | frv \
+	| e2k | epiphany \
+	| fido | fr30 | frv | ft32 \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| hexagon \
 	| i370 | i860 | i960 | ia64 \
@@ -283,8 +283,10 @@
 	| mips64vr5900 | mips64vr5900el \
 	| mipsisa32 | mipsisa32el \
 	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa32r6 | mipsisa32r6el \
 	| mipsisa64 | mipsisa64el \
 	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64r6 | mipsisa64r6el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipsr5900 | mipsr5900el \
@@ -296,11 +298,11 @@
 	| nds32 | nds32le | nds32be \
 	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
-	| open8 \
-	| or1k | or32 \
+	| open8 | or1k | or1knd | or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle \
 	| pyramid \
+	| riscv32 | riscv64 \
 	| rl78 | rx \
 	| score \
 	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
@@ -311,6 +313,7 @@
 	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
 	| ubicom32 \
 	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
+	| visium \
 	| we32k \
 	| x86 | xc16x | xstormy16 | xtensa \
 	| z8k | z80)
@@ -325,6 +328,9 @@
 	c6x)
 		basic_machine=tic6x-unknown
 		;;
+	leon|leon[3-9])
+		basic_machine=sparc-$basic_machine
+		;;
 	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
 		basic_machine=$basic_machine-unknown
 		os=-none
@@ -375,7 +381,7 @@
 	| c[123]* | c30-* | [cjt]90-* | c4x-* \
 	| c8051-* | clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
-	| elxsi-* \
+	| e2k-* | elxsi-* \
 	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
@@ -402,8 +408,10 @@
 	| mips64vr5900-* | mips64vr5900el-* \
 	| mipsisa32-* | mipsisa32el-* \
 	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa32r6-* | mipsisa32r6el-* \
 	| mipsisa64-* | mipsisa64el-* \
 	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64r6-* | mipsisa64r6el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipsr5900-* | mipsr5900el-* \
@@ -415,6 +423,7 @@
 	| nios-* | nios2-* | nios2eb-* | nios2el-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
 	| open8-* \
+	| or1k*-* \
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
@@ -432,6 +441,7 @@
 	| ubicom32-* \
 	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
 	| vax-* \
+	| visium-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xc16x-* | xps100-* \
 	| xstormy16-* | xtensa*-* \
@@ -508,6 +518,9 @@
 		basic_machine=i386-pc
 		os=-aros
 		;;
+        asmjs)
+		basic_machine=asmjs-unknown
+		;;
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
@@ -769,6 +782,9 @@
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
+	leon-*|leon[3-9]-*)
+		basic_machine=sparc-`echo $basic_machine | sed 's/-.*//'`
+		;;
 	m68knommu)
 		basic_machine=m68k-unknown
 		os=-linux
@@ -824,6 +840,10 @@
 		basic_machine=powerpc-unknown
 		os=-morphos
 		;;
+	moxiebox)
+		basic_machine=moxie-unknown
+		os=-moxiebox
+		;;
 	msdos)
 		basic_machine=i386-pc
 		os=-msdos
@@ -1356,7 +1376,7 @@
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
 	      | -sym* | -kopensolaris* | -plan9* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* | -aros* \
+	      | -aos* | -aros* | -cloudabi* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
@@ -1369,14 +1389,14 @@
 	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
 	      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
 	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
-	      | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* | -tirtos*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
@@ -1594,9 +1614,6 @@
 	mips*-*)
 		os=-elf
 		;;
-	or1k-*)
-		os=-elf
-		;;
 	or32-*)
 		os=-coff
 		;;
