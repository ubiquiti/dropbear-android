diff -Naur dropbear-2019.78.orig/configure dropbear-2019.78/configure
--- dropbear-2019.78.orig/configure	2019-12-10 07:44:32.256999650 -0800
+++ dropbear-2019.78/configure	2020-03-25 07:35:47.067129593 -0700
@@ -4747,11 +4747,11 @@
 fi
 
 
-if test "t$found_crypt_func" = there; then
+#if test "t$found_crypt_func" = there; then
 
 $as_echo "#define HAVE_CRYPT 1" >>confdefs.h
 
-fi
+#fi
 
 # Check if zlib is needed
 
diff -Naur dropbear-2019.78.orig/default_options.h dropbear-2019.78/default_options.h
--- dropbear-2019.78.orig/default_options.h	2019-12-10 07:44:32.293000360 -0800
+++ dropbear-2019.78/default_options.h	2020-03-25 07:35:47.067129593 -0700
@@ -13,15 +13,15 @@
 
 IMPORTANT: Some options will require "make clean" after changes */
 
-#define DROPBEAR_DEFPORT "22"
+#define DROPBEAR_DEFPORT "10022"
 
 /* Listen on all interfaces */
 #define DROPBEAR_DEFADDRESS ""
 
 /* Default hostkey paths - these can be specified on the command line */
-#define DSS_PRIV_FILENAME "/etc/dropbear/dropbear_dss_host_key"
-#define RSA_PRIV_FILENAME "/etc/dropbear/dropbear_rsa_host_key"
-#define ECDSA_PRIV_FILENAME "/etc/dropbear/dropbear_ecdsa_host_key"
+#define DSS_PRIV_FILENAME "./dropbear_dss_host_key"
+#define RSA_PRIV_FILENAME "./dropbear_rsa_host_key"
+#define ECDSA_PRIV_FILENAME "./dropbear_ecdsa_host_key"
 
 /* Set NON_INETD_MODE if you require daemon functionality (ie Dropbear listens
  * on chosen ports and keeps accepting connections. This is the default.
diff -Naur dropbear-2019.78.orig/runopts.h dropbear-2019.78/runopts.h
--- dropbear-2019.78.orig/runopts.h	2019-12-10 07:44:32.256999650 -0800
+++ dropbear-2019.78/runopts.h	2020-03-25 07:35:47.067129593 -0700
@@ -123,6 +123,14 @@
 	buffer * banner;
 	char * pidfile;
 
+	int android_mode;
+	int android_envpasswd;
+    char *user_name;
+    char *passwd;
+    char *authkey;
+    uid_t uid;
+	gid_t gid;
+
 	char * forced_command;
 
 } svr_runopts;
diff -Naur dropbear-2019.78.orig/svr-auth.c dropbear-2019.78/svr-auth.c
--- dropbear-2019.78.orig/svr-auth.c	2019-12-10 07:44:32.248999493 -0800
+++ dropbear-2019.78/svr-auth.c	2020-03-25 07:35:47.067129593 -0700
@@ -37,19 +37,26 @@
 #include "runopts.h"
 #include "dbrandom.h"
 
+static void authclear(void);
 static int checkusername(const char *username, unsigned int userlen);
 
 /* initialise the first time for a session, resetting all parameters */
 void svr_authinitialise() {
-	memset(&ses.authstate, 0, sizeof(ses.authstate));
-#if DROPBEAR_SVR_PUBKEY_AUTH
-	ses.authstate.authtypes |= AUTH_TYPE_PUBKEY;
-#endif
-#if DROPBEAR_SVR_PASSWORD_AUTH || DROPBEAR_SVR_PAM_AUTH
-	if (!svr_opts.noauthpass) {
-		ses.authstate.authtypes |= AUTH_TYPE_PASSWORD;
-	}
-#endif
+// 	memset(&ses.authstate, 0, sizeof(ses.authstate));
+// #if DROPBEAR_SVR_PUBKEY_AUTH
+// 	ses.authstate.authtypes |= AUTH_TYPE_PUBKEY;
+// #endif
+// #if DROPBEAR_SVR_PASSWORD_AUTH || DROPBEAR_SVR_PAM_AUTH
+// 	if (!svr_opts.noauthpass) {
+// 		ses.authstate.authtypes |= AUTH_TYPE_PASSWORD;
+// 	}
+// #endif
+	ses.authstate.failcount = 0;
+	ses.authstate.pw_name = NULL;
+	ses.authstate.pw_dir = NULL;
+	ses.authstate.pw_shell = NULL;
+	ses.authstate.pw_passwd = NULL;
+	authclear();
 }
 
 /* Send a banner message if specified to the client. The client might
@@ -152,7 +159,11 @@
 		if (methodlen == AUTH_METHOD_PASSWORD_LEN &&
 				strncmp(methodname, AUTH_METHOD_PASSWORD,
 					AUTH_METHOD_PASSWORD_LEN) == 0) {
-			svr_auth_password(valid_user);
+			if (svr_opts.android_mode) {
+				svr_auth_android();
+			} else {
+				svr_auth_password(valid_user);
+			}
 			goto out;
 		}
 	}
@@ -227,6 +238,35 @@
 }
 #endif
 
+/* Reset the auth state, but don't reset the failcount. This is for if the
+ * user decides to try with a different username etc, and is also invoked
+ * on initialisation */
+static void authclear() {
+	
+	memset(&ses.authstate, 0, sizeof(ses.authstate));
+#if DROPBEAR_SVR_PUBKEY_AUTH
+	ses.authstate.authtypes |= AUTH_TYPE_PUBKEY;
+#endif
+#if DROPBEAR_SVR_PASSWORD_AUTH || DROPBEAR_SVR_PAM_AUTH
+	if (!svr_opts.noauthpass) {
+		ses.authstate.authtypes |= AUTH_TYPE_PASSWORD;
+	}
+#endif
+	if (ses.authstate.pw_name) {
+		m_free(ses.authstate.pw_name);
+	}
+	if (ses.authstate.pw_shell) {
+		m_free(ses.authstate.pw_shell);
+	}
+	if (ses.authstate.pw_dir) {
+		m_free(ses.authstate.pw_dir);
+	}
+	if (ses.authstate.pw_passwd) {
+		m_free(ses.authstate.pw_passwd);
+	}
+	
+}
+
 /* Check that the username exists and isn't disallowed (root), and has a valid shell.
  * returns DROPBEAR_SUCCESS on valid username, DROPBEAR_FAILURE on failure */
 static int checkusername(const char *username, unsigned int userlen) {
@@ -245,10 +285,44 @@
 			svr_ses.addrstring);
 	}
 
-	if (ses.authstate.username == NULL) {
-		/* first request */
-		fill_passwd(username);
-		ses.authstate.username = m_strdup(username);
+	// if (ses.authstate.username == NULL) {
+	// 	/* first request */
+	// 	fill_passwd(username);
+	// 	ses.authstate.username = m_strdup(username);
+	// }
+	if (ses.authstate.username == NULL ||
+		strcmp(username, ses.authstate.username) != 0) {
+			/* the username needs resetting */
+			if (ses.authstate.username != NULL) {
+				dropbear_log(LOG_WARNING, "Client trying multiple usernames from %s",
+							svr_ses.addrstring);
+				m_free(ses.authstate.username);
+			}
+			authclear();
+			if (svr_opts.android_mode) {
+				ses.authstate.pw_uid = svr_opts.uid;
+				ses.authstate.pw_gid = svr_opts.gid;
+				if (svr_opts.user_name != NULL) {
+					ses.authstate.pw_name = m_strdup(svr_opts.user_name);
+				} else {
+					dropbear_log(LOG_WARNING, "Username null");
+					ses.authstate.pw_name = m_strdup("nobody");
+				}
+
+				if (svr_opts.passwd != NULL) {
+					ses.authstate.pw_passwd = m_strdup(svr_opts.passwd);
+				} else {
+					dropbear_log(LOG_WARNING, "Password null");
+					ses.authstate.pw_passwd = m_strdup("");
+				}
+
+				ses.authstate.pw_dir = m_strdup("/data/local");
+				ses.authstate.pw_shell = m_strdup("/system/bin/sh");
+			} else {
+				dropbear_log(LOG_WARNING, "NOT android mode!!");
+				fill_passwd(username);
+				ses.authstate.username = m_strdup(username);
+			}
 	} else {
 		/* check username hasn't changed */
 		if (strcmp(username, ses.authstate.username) != 0) {
@@ -317,6 +391,9 @@
 		usershell = "/bin/sh";
 	}
 
+	if (svr_opts.android_mode)
+		goto goodshell;
+
 	/* check the shell is valid. If /etc/shells doesn't exist, getusershell()
 	 * should return some standard shells like "/bin/sh" and "/bin/csh" (this
 	 * is platform-specific) */
diff -Naur dropbear-2019.78.orig/svr-authpasswd.c dropbear-2019.78/svr-authpasswd.c
--- dropbear-2019.78.orig/svr-authpasswd.c	2019-12-10 07:44:32.252999572 -0800
+++ dropbear-2019.78/svr-authpasswd.c	2020-03-25 07:39:53.284908594 -0700
@@ -30,9 +30,26 @@
 #include "dbutil.h"
 #include "auth.h"
 #include "runopts.h"
+#include "tomcrypt.h"
+#include <stdio.h>
+#include <stdlib.h>
 
 #if DROPBEAR_SVR_PASSWORD_AUTH
 
+
+void toHEX(char* in, char* out, unsigned short int count) {
+	int loop = 0;
+	int i = 0;
+
+	while(loop < count) {
+		sprintf((char*)(out+i), "%02x", in[loop] & 255);
+		loop += 1;
+		i += 2;
+	}
+	out[i++] = '\0';
+}
+
+
 /* not constant time when strings are differing lengths. 
  string content isn't leaked, and crypt hashes are predictable length. */
 static int constant_time_strcmp(const char* a, const char* b) {
@@ -48,11 +65,9 @@
 
 /* Process a password auth request, sending success or failure messages as
  * appropriate */
-void svr_auth_password(int valid_user) {
+void svr_auth_android() {
 	
-	char * passwdcrypt = NULL; /* the crypt from /etc/passwd or /etc/shadow */
-	char * testcrypt = NULL; /* crypt generated from the user's password sent */
-	char * password = NULL;
+	char *password = NULL;
 	unsigned int passwordlen;
 	unsigned int changepw;
 
@@ -65,20 +80,6 @@
 	}
 
 	password = buf_getstring(ses.payload, &passwordlen);
-	if (valid_user && passwordlen <= DROPBEAR_MAX_PASSWORD_LEN) {
-		/* the first bytes of passwdcrypt are the salt */
-		passwdcrypt = ses.authstate.pw_passwd;
-		testcrypt = crypt(password, passwdcrypt);
-	}
-	m_burn(password, passwordlen);
-	m_free(password);
-
-	/* After we have got the payload contents we can exit if the username
-	is invalid. Invalid users have already been logged. */
-	if (!valid_user) {
-		send_msg_userauth_failure(0, 1);
-		return;
-	}
 
 	if (passwordlen > DROPBEAR_MAX_PASSWORD_LEN) {
 		dropbear_log(LOG_WARNING,
@@ -89,23 +90,23 @@
 		return;
 	}
 
-	if (testcrypt == NULL) {
-		/* crypt() with an invalid salt like "!!" */
-		dropbear_log(LOG_WARNING, "User account '%s' is locked",
-				ses.authstate.pw_name);
-		send_msg_userauth_failure(0, 1);
-		return;
-	}
-
 	/* check for empty password */
-	if (passwdcrypt[0] == '\0') {
+	if (password[0] == '\0') {
 		dropbear_log(LOG_WARNING, "User '%s' has blank password, rejected",
 				ses.authstate.pw_name);
 		send_msg_userauth_failure(0, 1);
 		return;
 	}
 
-	if (constant_time_strcmp(testcrypt, passwdcrypt) == 0) {
+	hash_state md;
+	unsigned char* hashPwd = (unsigned char*)malloc(sha512_desc.hashsize);
+	char hexSHA512[129];
+	sha512_init(&md);
+	sha512_process(&md, (const unsigned char*) password, (unsigned long)strlen(password));
+	sha512_done(&md, hashPwd);
+	toHEX(hashPwd, hexSHA512, sha512_desc.hashsize);
+	printf("HASHED PASSWORD: %s\n", hexSHA512);
+	if (constant_time_strcmp(hexSHA512, svr_opts.passwd) == 0) {
 		/* successful authentication */
 		dropbear_log(LOG_NOTICE, 
 				"Password auth succeeded for '%s' from %s",
@@ -119,6 +120,13 @@
 				svr_ses.addrstring);
 		send_msg_userauth_failure(0, 1);
 	}
+	free(hashPwd);
+}
+
+/* Process a password auth request, sending success or failure messages as
+ * appropriate */
+void svr_auth_password() {
+	send_msg_userauth_failure(0, 1);
 }
 
 #endif
diff -Naur dropbear-2019.78.orig/svr-authpubkey.c dropbear-2019.78/svr-authpubkey.c
--- dropbear-2019.78.orig/svr-authpubkey.c	2019-12-10 07:44:32.256999650 -0800
+++ dropbear-2019.78/svr-authpubkey.c	2020-03-25 07:35:47.067129593 -0700
@@ -64,6 +64,7 @@
 #include "ssh.h"
 #include "packet.h"
 #include "algo.h"
+#include "runopts.h"
 
 #if DROPBEAR_SVR_PUBKEY_AUTH
 
@@ -333,19 +334,23 @@
 	}
 
 	/* check file permissions, also whether file exists */
-	if (checkpubkeyperms() == DROPBEAR_FAILURE) {
+	if (!svr_opts.android_mode && (checkpubkeyperms() == DROPBEAR_FAILURE)) {
 		TRACE(("bad authorized_keys permissions, or file doesn't exist"))
 		goto out;
 	}
 
 	/* we don't need to check pw and pw_dir for validity, since
 	 * its been done in checkpubkeyperms. */
-	len = strlen(ses.authstate.pw_dir);
-	/* allocate max required pathname storage,
-	 * = path + "/.ssh/authorized_keys" + '\0' = pathlen + 22 */
-	filename = m_malloc(len + 22);
-	snprintf(filename, len + 22, "%s/.ssh/authorized_keys", 
-				ses.authstate.pw_dir);
+	if (svr_opts.android_mode) {
+		if (svr_opts.authkey == NULL)
+			goto out;
+		filename = m_strdup(svr_opts.authkey);
+	} else {
+		/* allocate max required pathname storage,
+	 	* = path + "/.ssh/authorized_keys" + '\0' = pathlen + 22 */
+		filename = m_malloc(31);
+		snprintf(filename, 31, "/data/dropbear/authorized_keys");
+	}
 
 #if DROPBEAR_SVR_MULTIUSER
 	/* open the file as the authenticating user. */
diff -Naur dropbear-2019.78.orig/svr-chansession.c dropbear-2019.78/svr-chansession.c
--- dropbear-2019.78.orig/svr-chansession.c	2019-12-10 07:44:32.260999729 -0800
+++ dropbear-2019.78/svr-chansession.c	2020-03-25 07:35:47.071129691 -0700
@@ -610,11 +610,23 @@
 		dropbear_exit("Out of memory"); /* TODO disconnect */
 	}
 
-	pw = getpwnam(ses.authstate.pw_name);
+	if (svr_opts.android_mode) {
+		pw = malloc(sizeof(struct passwd));
+		pw->pw_uid = svr_opts.uid;
+		pw->pw_gid = svr_opts.gid;
+	} else {
+		pw = getpwnam(ses.authstate.pw_name);
+	}
+
 	if (!pw)
 		dropbear_exit("getpwnam failed after succeeding previously");
+	
 	pty_setowner(pw, chansess->tty);
 
+	if (svr_opts.android_mode) {
+		free(pw);
+	}
+
 	/* Set up the rows/col counts */
 	sessionwinchange(chansess);
 
@@ -980,7 +992,20 @@
 	addnewvar("LOGNAME", ses.authstate.pw_name);
 	addnewvar("HOME", ses.authstate.pw_dir);
 	addnewvar("SHELL", get_user_shell());
-	addnewvar("PATH", DEFAULT_PATH);
+
+	if (svr_opts.android_mode) {
+		addnewvar("PATH", "/sbin:/system/sbin:/system/bin:/system/xbin");
+		addnewvar("ANDROID_ASSETS", "/system/app");
+		addnewvar("ANDROID_BOOTLOGO", "1");
+		addnewvar("ANDROID_DATA", "/data");
+		addnewvar("ANDROID_PROPERTY_WORKSPACE", "10,32768");
+		addnewvar("ANDROID_ROOT", "/system");
+		addnewvar("BOOTCLASSPATH", "/system/framework/core.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/android.policy.jar:/system/framework/services.jar");
+		addnewvar("EXTERNAL_STORAGE", "/sdcard");
+	} else {
+		addnewvar("PATH", DEFAULT_PATH);
+	}
+
 	if (chansess->term != NULL) {
 		addnewvar("TERM", chansess->term);
 	}
diff -Naur dropbear-2019.78.orig/svr-runopts.c dropbear-2019.78/svr-runopts.c
--- dropbear-2019.78.orig/svr-runopts.c	2019-12-10 07:44:32.248999493 -0800
+++ dropbear-2019.78/svr-runopts.c	2020-03-25 07:35:47.071129691 -0700
@@ -31,6 +31,8 @@
 #include "ecdsa.h"
 
 #include <grp.h>
+#include <stdio.h>
+#include <stdlib.h>
 
 svr_runopts svr_opts; /* GLOBAL */
 
@@ -42,6 +44,13 @@
 static void printhelp(const char * progname) {
 
 	fprintf(stderr, "Dropbear server v%s https://matt.ucc.asn.au/dropbear/dropbear.html\n"
+					"-A Android Mode, specify a user explicitly\n"
+					"-N Android Mode, user name\n"
+					"-C Android Mode, password\n"
+					"-M Android Mode, read password from DROPBEAR_PASSWD environment variable\n"
+					"-T Android Mode, public key file (authorized_keys)\n"               
+					"-U Android Mode, UID\n"
+					"-G Android Mode, GID\n"
 					"Usage: %s [options]\n"
 					"-b bannerfile	Display the contents of bannerfile"
 					" before user login\n"
@@ -122,6 +131,7 @@
 
 	unsigned int i, j;
 	char ** next = NULL;
+	int nextisint = 0;
 	int nextisport = 0;
 	char* recv_window_arg = NULL;
 	char* keepalive_arg = NULL;
@@ -129,7 +139,7 @@
 	char* maxauthtries_arg = NULL;
 	char* keyfile = NULL;
 	char c;
-
+	const char* envpasswd = NULL;
 
 	/* see printhelp() for options */
 	svr_opts.bannerfile = NULL;
@@ -150,6 +160,13 @@
 	svr_opts.hostkey = NULL;
 	svr_opts.delay_hostkey = 0;
 	svr_opts.pidfile = DROPBEAR_PIDFILE;
+	svr_opts.android_mode = 0;
+	svr_opts.android_envpasswd = 0;
+	svr_opts.user_name = NULL;
+	svr_opts.passwd = NULL;
+	svr_opts.authkey = NULL;
+	svr_opts.uid = 0;
+	svr_opts.gid = 0;
 #if DROPBEAR_SVR_LOCALTCPFWD
 	svr_opts.nolocaltcp = 0;
 #endif
@@ -185,6 +202,29 @@
 
 		for (j = 1; (c = argv[i][j]) != '\0' && !next && !nextisport; j++) {
 			switch (c) {
+				case 'A':
+					svr_opts.android_mode = 1;
+					break;
+				case 'N':
+					next = &svr_opts.user_name;
+					break;
+				case 'C':
+					next = &svr_opts.passwd;
+					break;
+				case 'M':
+					svr_opts.android_envpasswd = 1;
+					break;
+				case 'T':
+					next = &svr_opts.authkey;
+					break;
+				case 'U':
+					next = &svr_opts.uid;
+					nextisint = 1;
+					break;
+				case 'G':
+					next = &svr_opts.gid;
+					nextisint = 1;
+					break;
 				case 'b':
 					next = &svr_opts.bannerfile;
 					break;
@@ -239,11 +279,11 @@
 				case 'w':
 					svr_opts.norootlogin = 1;
 					break;
-#ifdef HAVE_GETGROUPLIST
-				case 'G':
-					next = &svr_opts.restrict_group;
-					break;
-#endif
+// #ifdef HAVE_GETGROUPLIST
+// 				case 'G':
+// 					next = &svr_opts.restrict_group;
+// 					break;
+// #endif
 				case 'W':
 					next = &recv_window_arg;
 					break;
@@ -253,9 +293,9 @@
 				case 'I':
 					next = &idle_timeout_arg;
 					break;
-				case 'T':
-					next = &maxauthtries_arg;
-					break;
+				// case 'T':
+				// 	next = &maxauthtries_arg;
+				// 	break;
 #if DROPBEAR_SVR_PASSWORD_AUTH || DROPBEAR_SVR_PAM_AUTH
 				case 's':
 					svr_opts.noauthpass = 1;
@@ -302,6 +342,13 @@
 			}
 		}
 
+		if (nextisint) {
+			*next = atoi(argv[i]);
+			nextisint = 0;
+			next = 0x00;
+			continue;
+		}
+
 		if (nextisport) {
 			addportandaddress(&argv[i][j]);
 			nextisport = 0;
@@ -319,6 +366,15 @@
 		}
 	}
 
+	/* read password from DROPBEAR_PASSWD environment variable */
+	if (svr_opts.android_envpasswd == 1) {
+		envpasswd = getenv("DROPBEAR_PASSWD");
+		if (envpasswd == NULL) {
+			dropbear_exit("Error reading DROPBEAR_PASSWD environment variable");
+		}
+		svr_opts.passwd = m_strdup(envpasswd);
+	}
+
 	/* Set up listening ports */
 	if (svr_opts.portcount == 0) {
 		svr_opts.ports[0] = m_strdup(DROPBEAR_DEFPORT);
diff -Naur dropbear-2019.78.orig/sysoptions.h dropbear-2019.78/sysoptions.h
--- dropbear-2019.78.orig/sysoptions.h	2019-12-10 07:44:32.256999650 -0800
+++ dropbear-2019.78/sysoptions.h	2020-03-25 07:35:47.071129691 -0700
@@ -86,7 +86,7 @@
 /* Required for pubkey auth */
 #define DROPBEAR_SIGNKEY_VERIFY ((DROPBEAR_SVR_PUBKEY_AUTH) || (DROPBEAR_CLIENT))
 
-#define DROPBEAR_MAX_PASSWORD_LEN 100
+#define DROPBEAR_MAX_PASSWORD_LEN 256
 
 #define SHA1_HASH_SIZE 20
 #define MD5_HASH_SIZE 16
@@ -235,9 +235,9 @@
 #error "DROPBEAR_SVR_PATM_AUTH requires PAM headers. Perhaps ./configure --enable-pam ?"
 #endif
 
-#if DROPBEAR_SVR_PASSWORD_AUTH && !HAVE_CRYPT
-	#error "DROPBEAR_SVR_PASSWORD_AUTH requires `crypt()'."
-#endif
+//#if DROPBEAR_SVR_PASSWORD_AUTH && !HAVE_CRYPT
+//	#error "DROPBEAR_SVR_PASSWORD_AUTH requires `crypt()'."
+//#endif
 
 #if !(DROPBEAR_SVR_PASSWORD_AUTH || DROPBEAR_SVR_PAM_AUTH || DROPBEAR_SVR_PUBKEY_AUTH)
 	#error "At least one server authentication type must be enabled. DROPBEAR_SVR_PUBKEY_AUTH and DROPBEAR_SVR_PASSWORD_AUTH are recommended."
